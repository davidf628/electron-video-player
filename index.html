<!DOCTYPE html>
<html>
  <head>

    <meta charset="UTF-8">
    <link type="text/css" rel="stylesheet" href="./node_modules/video.js/dist/video-js.min.css" />
    <script src="./js/d3.js"></script>
    <script src="./js/d3misc.js"></script>
    <title>MATH 104 Video Player</title>

  </head>

<body>

  <video
    id="vid1"
    class="video-js vjs-default-skin"
    controls
    preload='auto'
    autoplay
    width="640" height="480
    "
    data-setup='{ "muted": true, 
                  "techOrder": ["youtube", "html5"], 
                  "sources": [
                     { "type": "video/youtube", "src": "https://youtu.be/DNQOjVkixqI"}], 
                  "youtube": { "ytControls": 2 }  }'
  >
  </video>

  <script src="./node_modules/video.js/dist/video.js"></script>
  <script src="./dist/Youtube.js"></script>

  <input type="button" value="Play Video 1" onclick="changeVideo()" />

  <div id="status-bar">
    <svg id="status-background">

    </svg>
  </div>

  <script>

    player = videojs('vid1');
    player.fluid(true);

    player.ready(() => {

      xScale.range([0, player.duration()]);

      myTimer = setInterval(
        function () { 
          intervalsWatched = addToPlayedIntervals(player.currentTime(), intervalsWatched);
          drawProgress(intervalsWatched); 
        }, 
      1000);

    });

    intervalsWatched = [];

    function drawProgress(intervals_watched) {
      d3.select('#chart-area').remove();
      let chart_area = d3.select('#status-background')
        .append('g')
        .attr('id', 'chart-area')
      chart_area.selectAll("rect")
        .data(intervals_watched)
        .enter()
        .append("rect")
        .attr("x", (d, i) => { return xScale(d[0]); })
        .attr("y", 0)
        .attr("width", (d) => { return xScale(d[1] - d[0]); })
        .attr("height", 50)
        .attr("fill", "blue")
        .attr("stroke", "black");
    }

    function changeVideo() {
     // "sources": [{ "type": "video/youtube", "src": "https://youtu.be/DwnLK_gbHuI"}]
      player.src({ type: 'video/youtube', src: 'https://youtu.be/DwnLK_gbHuI' })
    }

    let svg = d3.select('#status-background')
      .attr('width', 600)
      .attr('height', 50);

    setBackground(svg, 600, 50, "lightgray", "black");

    svg
      .append('g')
      .attr('id', 'chart-area');

    let xScale = d3.scaleLinear().domain([0, 600]);




  

    //intervalsWatched = [ [0, 10.98], [64.97, 69.86], [15, 25] ]
    //intervalsWatched = addToPlayedIntervals(158.34, intervalsWatched);
    //console.log(intervalsWatched);
    //intervalsWatched = addToPlayedIntervals(2, intervalsWatched);
    //intervalsWatched = addToPlayedIntervals(3, intervalsWatched);
    //intervalsWatched = addToPlayedIntervals(7, intervalsWatched);
    //intervalsWatched = addToPlayedIntervals(9, intervalsWatched);
    //intervalsWatched = addToPlayedIntervals(6, intervalsWatched);
    //intervalsWatched = addToPlayedIntervals(5, intervalsWatched);
    //intervalsWatched = addToPlayedIntervals(4, intervalsWatched);
    //intervalsWatched = addToPlayedIntervals(20, intervalsWatched);



    function swapArrayItems(u, v, array) {
      let temp = array[u];
      array.splice(u, 1, array[v]);
      array.splice(v, 1, temp);
      return array;
    }

    function addToPlayedIntervals(current_time, intervals_watched) {
      
      // Initialize array if the video has just been started
      if (intervals_watched.length == 0) {

        if (current_time < 3) {
          intervals_watched.push([0, current_time]);
        } else {
          intervals_watched.push([current_time, current_time + 1]);
        }

      } else {

        // Sort the array, if necessary
      if (intervals_watched.length >= 2) {

          for (let i = 0; i < intervals_watched.length - 1; i++) {
            for (let j = i+1; j < intervals_watched.length; j++) {

              let begin_first = intervals_watched[i][0];
              let end_first = intervals_watched[i][1];
    
              let begin_next = intervals_watched[j][0];
              let end_next = intervals_watched[j][1];
    
              // Check to make sure the intervals are valid:
              if ((end_first < begin_first) || (end_next < begin_next)) {
                console.log(`ERROR! Interval is inverted! ${intervals_watched}`);
              } else if (begin_next < begin_first) {
                intervals_watched = swapArrayItems(i, j, intervals_watched);
              }

            }
          }

        }

        // Check to see if any adjacent time intervals can be joined
        for (let i = 0; i < intervals_watched.length - 1; i++) {

          let begin_current = intervals_watched[i][0];
          let end_current = intervals_watched[i][1];

          let begin_next = intervals_watched[i+1][0];
          let end_next = intervals_watched[i+1][1];

          if (Math.abs(begin_next - end_current) < 3) {
            intervals_watched.splice(i, 2, [begin_current, end_next]);
          } 
        }

        // Check to see if the current time is within any of the intervals
        //  if so, ignore this case
        for (let interval of intervals_watched) {
          let start = interval[0];
          let end = interval[1];
          if ((current_time > start) && (current_time < end)) {
            return intervals_watched;
          }
        }

        // Check to see if the current time is within 3 seconds of the end
        //  of any interval, if so, then extend that interval
        for (let interval of intervals_watched) {
          let start = interval[0];
          let end = interval[1];

          if (Math.abs(current_time - end) < 3)  {

            let index = intervals_watched.indexOf(interval);
            interval = [ start, current_time ];
            intervals_watched.splice(index, 1, interval);

            return intervals_watched;
          }

        }

        // Check to see if the current time is within 3 seconds of the
        //  start of any interval, if so, then extend that interval
        for (let interval of intervals_watched) {
          let start = interval[0];
          let end = interval[1];

          if (Math.abs(start - current_time) < 3) {

            let index = intervals_watched.indexOf(interval);
            interval = [ current_time, end ];
            intervals_watched.splice(index, 1, interval);

            return intervals_watched;
          }

        }

        // Check to see if the current time is more than 3 seconds away
        //  from the end of any interval, if so create a new interval
        //  Start checking from the end to make sure the "best" placement
        //  occurs
        for (let i = intervals_watched.length - 1; i >= 0; i--) {

          let interval = intervals_watched[i];

          let start = interval[0];
          let end = interval[1];

          if (Math.abs(current_time - end) > 3) {

            let new_interval = [ current_time, current_time + 1 ];
            intervals_watched.splice(i + 1, 0, new_interval);

            return intervals_watched;
          }

        }       


      }

      return intervals_watched;

    }

  </script>


</body>

</html>